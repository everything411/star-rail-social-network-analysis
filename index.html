<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>é“¶æ²³è§’è‰²å…³ç³»ç½‘ç»œåˆ†æå™¨ (å´©åï¼šæ˜Ÿç©¹é“é“)</title>
<style>
:root{--bg-color:#f4f7f9;--card-bg:#fff;--primary-text:#333;--secondary-text:#666;--border-color:#e0e0e0;--accent-color:#4a90e2;--accent-hover:#357ab8}
body{font-family:'Helvetica Neue',Arial,'Hiragino Sans GB','Microsoft YaHei',sans-serif;background-color:var(--bg-color);color:var(--primary-text);line-height:1.6;margin:0;padding:20px}
.container{max-width:1600px;margin:auto;display:flex;flex-direction:column;gap:20px}
.card{background-color:var(--card-bg);border:1px solid var(--border-color);border-radius:12px;padding:25px;box-shadow:0 4px 12px rgba(0,0,0,.05)}
h1,h2,h3{color:var(--primary-text);border-bottom:2px solid var(--border-color);padding-bottom:10px;margin-top:0}
h1{font-size:2em}h2{font-size:1.5em}h3{font-size:1.2em;border-bottom:none}
button{padding:12px 25px;font-size:16px;font-weight:bold;background-color:var(--accent-color);color:#fff;border:none;border-radius:8px;cursor:pointer;transition:background-color .2s ease,transform .1s ease}
button:disabled{background-color:#ccc;cursor:not-allowed}
button:not(:disabled):hover{background-color:var(--accent-hover);transform:translateY(-1px)}
.output-container{display:grid;grid-template-columns:3fr 2fr;gap:20px;min-height:80vh}
#network-visualization{width:100%;height:800px;background-color:#222;border:1px solid #d3d3d3;position:relative;border-radius:8px;}
.analysis-panel{overflow-y:auto;height:80vh;padding-right:15px}
.analysis-panel::-webkit-scrollbar{width:8px}
.analysis-panel::-webkit-scrollbar-track{background:#f1f1f1}
.analysis-panel::-webkit-scrollbar-thumb{background:#ccc;border-radius:4px}
.analysis-panel::-webkit-scrollbar-thumb:hover{background:#aaa}
table{width:100%;border-collapse:collapse;margin:20px 0}
th,td{padding:12px;text-align:left;border-bottom:1px solid var(--border-color)}
th{background-color:#f9f9f9;font-weight:bold}
.community-list{padding-left:0;list-style:none}
.community-list li{background:#f9f9f9;padding:12px;border-radius:6px;margin-bottom:8px;border-left:4px solid var(--accent-color)}
.loader{border:5px solid #f3f3f3;border-top:5px solid var(--accent-color);border-radius:50%;width:40px;height:40px;animation:spin 1s linear infinite;margin:20px auto}
@keyframes spin{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}
@media(max-width:1024px){.output-container{grid-template-columns:1fr}#network-visualization{height:60vh}.analysis-panel{height:auto;max-height:70vh}}
</style>
<!-- å¼•å…¥ vis-network çš„æ ·å¼ -->
<link href="https://unpkg.com/vis-network/styles/vis-network.min.css" rel="stylesheet">
</head>
<body>
<div class="container">
  <div class="card"><h1>é“¶æ²³è§’è‰²å…³ç³»ç½‘ç»œåˆ†æå™¨</h1></div>
  <div id="output-section" class="card">
    <div class="output-container">
      <div id="network-visualization">
        <div class="loader"></div>
        <p style="text-align: center; color: white;">æ­£åœ¨åŠ è½½å’Œåˆ†ææ•°æ®ï¼Œè¯·ç¨å€™...</p>
      </div>
      <div id="analysis-results" class="analysis-panel"></div>
    </div>
  </div>
</div>
<script type="module">
import Graph from 'https://cdn.jsdelivr.net/npm/graphology/+esm';
import louvain from 'https://cdn.jsdelivr.net/npm/graphology-communities-louvain/+esm';
import betweennessCentrality from 'https://cdn.jsdelivr.net/npm/graphology-metrics/centrality/betweenness.js/+esm';
import { Network } from 'https://cdn.jsdelivr.net/npm/vis-network/peer/esm/vis-network.min.js/+esm';
import { DataSet } from 'https://cdn.jsdelivr.net/npm/vis-data@8.0.3/peer/esm/vis-data.js/+esm';

const resultsDiv = document.getElementById('analysis-results');
const vizContainer = document.getElementById('network-visualization');

async function fetchAndDecompress(url) {
  const res = await fetch(url);
  if (!res.ok) throw new Error(`åŠ è½½å¤±è´¥: ${url}`);
  const blob = await res.blob();
  const decompressed = await new Response(blob.stream().pipeThrough(new DecompressionStream('gzip'))).blob();
  let text = await decompressed.text();
  
  text = text.replace(
      /:\s*(\d{16,})\s*([,\}\]])/g, 
      (match, number, delimiter) => {
          // åŒ¹é…åˆ°çš„æ•°å­—éƒ¨åˆ†é•¿åº¦å¤§äºç­‰äº16ä½ï¼ˆç»å¯¹å®‰å…¨çº¿ï¼‰
          return `: "${number}"${delimiter}`;
      }
  );
  
  text = text.replace(
      /\[\s*(\d{16,})\s*([,\}\]])/g,
      (match, number, delimiter) => {
          return `[ "${number}"${delimiter}`;
      }
  );
  
  // ç°åœ¨æ‰€æœ‰å¤§æ•´æ•°å“ˆå¸Œå€¼åœ¨ JSON è§£ææ—¶éƒ½ä¼šè¢«è§†ä¸ºå­—ç¬¦ä¸²
  return JSON.parse(text);
}


function loadAvatarIdToName(avatarData, textMap) {
  const avatarIdToName = {};
  avatarData.forEach(avatar => {
      const avatarId = avatar.AvatarID;
      const nameHash = avatar.AvatarName?.Hash; 
      
      if (avatarId && nameHash !== undefined && textMap[nameHash]) {
          avatarIdToName[avatarId] = textMap[nameHash];
        }
    });
  return avatarIdToName;
}


function extractMentionedCharacters(text, allNames) {
  let longestMatch = null;
  let maxLength = 0;

  for (const name of allNames) {
    if (text.includes(name)) {
      const currentLength = name.length;
      if (currentLength > maxLength) {
        maxLength = currentLength;
        longestMatch = name;
      }
    }
  }
  return longestMatch;
}

function buildMentionGraph(voiceAtlasData, textMap, avatarIdToName) {
  const graph = new Graph({ type: 'directed' });

  const aliasMap = {
      'æ‰˜å¸•': 'æ‰˜å¸•&è´¦è´¦'
  };

  const allAvatarNames = new Set(Object.values(avatarIdToName));
  const allMentionNames = new Set([...allAvatarNames]);
  Object.keys(aliasMap).forEach(alias => allMentionNames.add(alias));

  voiceAtlasData.forEach(voiceEntry => {
    const avatarId = voiceEntry.AvatarID;
    if (!avatarId || !avatarIdToName[avatarId]) return;
    
    const speakerName = avatarIdToName[avatarId];
    if (speakerName === "{NICKNAME}") return; 
    
    const voiceTitleHash = String(voiceEntry.VoiceTitle?.Hash || '');
    const voiceTitle = textMap[voiceTitleHash] || '';
    if (!voiceTitle) return;

    graph.mergeNode(speakerName);

    const mentionedNames = extractMentionedCharacters(voiceTitle, allMentionNames);
    if (mentionedNames && mentionedNames !== "{NICKNAME}") {
        const mentionedName = aliasMap[mentionedNames] || mentionedNames;
        if (mentionedName !== speakerName) {
            graph.mergeNode(mentionedName);
            graph.mergeEdge(speakerName, mentionedName);
            console.log("add edge " + speakerName + " to " + mentionedName)
        }
    }
  });
  return graph;
}


function analyzeGraph(graph) {
  const inDegrees = [], outDegrees = [];
  graph.forEachNode(node => {
    inDegrees.push({ id: node, degree: graph.inDegree(node) });
    outDegrees.push({ id: node, degree: graph.outDegree(node) });
  });

  const undirectedGraph = graph;
  louvain.assign(undirectedGraph);

  // ä¸­ä»‹ä¸­å¿ƒæ€§
  const betweenness = betweennessCentrality(graph);
  
  // æå–ç¤¾åŒºä¿¡æ¯
  const communities = {};
  undirectedGraph.forEachNode((node, attrs)=>{
    const commId = attrs.community;
    if (!communities[commId]) communities[commId] = [];
    communities[commId].push(node);
  });
  
  const allDegrees = Object.values(undirectedGraph.degree).map(v => v.degree);
  const avgDegree = allDegrees.length ? allDegrees.reduce((a, b) => a + b) / allDegrees.length : 0;
  
  const coreNodes = [];
  graph.forEachNode(node => {
      if (graph.degree(node) > avgDegree * 2) { // ç®€å•é˜ˆå€¼åˆ¤æ–­
          coreNodes.push(node);
      }
  });


  return {
    nNodes: graph.order,
    nEdges: graph.size,
    density: graph.density,
    topInDegree: inDegrees.sort((a,b)=>b.degree-a.degree).slice(0,5),
    topOutDegree: outDegrees.sort((a,b)=>b.degree-a.degree).slice(0,5),
    topBetweenness: Object.entries(betweenness).map(([id,v])=>({id,value:v})).sort((a,b)=>b.value-a.value).slice(0,5),
    communities: Object.values(communities).sort((a,b)=>b.length-a.length),
    coreNodes: coreNodes
  };
}


function renderResults(results) {
  const reciprocity = (graph) => {
    let reciprocalEdges = 0;
    graph.forEachEdge((edge, attrs, source, target) => {
        if (graph.hasEdge(target, source)) {
            reciprocalEdges++;
        }
    });
    return (reciprocalEdges / 2) / graph.size;
  };
  const graph = window._GLOBAL_GRAPH;
  const reciprocalRatio = graph ? reciprocity(graph) : 0;

  resultsDiv.innerHTML = `
    <h2>åˆ†ææŠ¥å‘Š</h2>
    <h3>åŸºæœ¬æŒ‡æ ‡</h3>
    <table>
      <tr><th>æŒ‡æ ‡</th><th>å€¼</th></tr>
      <tr><td>è§’è‰²æ•° (èŠ‚ç‚¹)</td><td>${results.nNodes}</td></tr>
      <tr><td>è¯„ä»·å…³ç³»æ•° (è¾¹)</td><td>${results.nEdges}</td></tr>
      <tr><td>ç½‘ç»œå¯†åº¦</td><td>${results.density}</td></tr>
      <tr><td>ç¤¾åŒºæ•°é‡</td><td>${results.communities.length}</td></tr>
      <tr><td>äº’æƒ è¾¹æ¯”ä¾‹</td><td>${reciprocalRatio}</td></tr>
    </table>
    
    ${createCentralityTable('ğŸ“¢ æœ€æ´»è·ƒè€… (å‡ºåº¦Top 5)', results.topOutDegree, 'degree', 'å‡ºåº¦')}
    ${createCentralityTable('ğŸ† æœ€å—æ¬¢è¿è€… (å…¥åº¦Top 5)', results.topInDegree, 'degree', 'å…¥åº¦')}
    ${createCentralityTable('ğŸ”— æœ€å…·å½±å“åŠ› (ä¸­ä»‹ä¸­å¿ƒæ€§Top 5)', results.topBetweenness, 'value', 'ä¸­å¿ƒæ€§')}
    
    <h3>æ ¸å¿ƒèŠ‚ç‚¹ (åŸºäºé«˜å‡ºå…¥åº¦)</h3>
    <p>${results.coreNodes.join(', ')}</p>

    <h3>ç¤¾åŒºåˆ’åˆ† (Top 10)</h3>
    <ul class="community-list">
      ${results.communities.slice(0,10).map((c,i)=>
        `<li><strong>ç¤¾åŒº ${i+1} (${c.length}å):</strong> ${c.join(', ')}</li>`).join('')}
      ${results.communities.length>10?`<li>... è¿˜æœ‰ ${results.communities.length-10} ä¸ªå°ç¤¾åŒº</li>`:''}
    </ul>`;
}

function createCentralityTable(title, data, valueKey, valueLabel) {
  return `<h3>${title}</h3>
    <table>
      <tr><th>æ’å</th><th>è§’è‰²</th><th>${valueLabel}</th></tr>
      ${data.map((item,i)=>
        `<tr><td>${i+1}</td><td>${item.id}</td><td>${valueKey === 'value' ? item[valueKey].toFixed(4) : item[valueKey]}</td></tr>`).join('')}
    </table>`;
}


function renderVisualization(graph) {
  const nodes = new DataSet();
  const edges = new DataSet();
  
  // é¢œè‰²æ˜ å°„ (æœ€å¤šæ”¯æŒ20ä¸ªç¤¾åŒºï¼Œè¶…å‡ºåå¾ªç¯ä½¿ç”¨)
  const colors = [
    '#FF5733', '#33FF57', '#3357FF', '#FF33A1', '#33FFF3', 
    '#A133FF', '#FF8F33', '#33A1FF', '#FF3333', '#33FFB5',
    '#8D33FF', '#FF336F', '#33FF8D', '#FFB533', '#336FFF',
    '#B533FF', '#FF338D', '#6FFF33', '#FF33F7', '#33C7FF'
  ];

  graph.forEachNode((node, attrs) => {
    const communityId = attrs.community || 0;
    nodes.add({
      id: node,
      label: node,
      group: communityId,
      color: colors[communityId % colors.length], // æ ¹æ®ç¤¾åŒºç€è‰²
      value: graph.degree(node), // ç”¨äºèŠ‚ç‚¹å¤§å°
      title: `è§’è‰²ï¼š ${node}\nç¤¾åŒº: ${communityId}\nå…¥åº¦: ${graph.inDegree(node)}\nå‡ºåº¦: ${graph.outDegree(node)}`
    });
  });

  graph.forEachEdge((edge, attrs, source, target) => {
    edges.add({ 
      from: source, 
      to: target, 
      arrows: { to: { enabled: true, scaleFactor: 0.5 } },
      color: { color: '#888888', highlight: '#ffffff' }
    });
  });

  const options = {
    layout: {
      randomSeed: 42 // ä¿æŒå¸ƒå±€ä¸€è‡´æ€§
    },
    nodes: {
        shape: 'dot',
        size: 15,
        font: { color: '#ffffff' }
    },
    edges: { 
        color: { inherit: 'from' }, 
        smooth: { enabled: true, type: "dynamic" } 
    },
    physics: {
      enabled: true,
      solver: 'barnesHut',
      barnesHut: { 
        gravitationalConstant: -20000, 
        centralGravity: 0.3, 
        springLength: 150, 
        springConstant: 0.05, 
        damping: 0.8, 
        avoidOverlap: 0.2 
      },
      stabilization: { enabled: true, iterations: 500, fit: true }
    }
  };
  
  // æ¸…ç©ºåŠ è½½æç¤º
  vizContainer.innerHTML = ''; 
  new Network(vizContainer, { nodes, edges }, options);
}

async function main() {
  resultsDiv.innerHTML = `<div class="loader"></div><p style="text-align: center;">æ­£åœ¨åŠ è½½å’Œåˆ†ææ•°æ®...</p>`;
  try {
    // å‡è®¾æ•°æ®æ–‡ä»¶è¢«å‘½åä¸º HSR å¯¹åº”çš„åç§°å¹¶å‹ç¼©
    const [textMapData, avatarData, voiceAtlasData] = await Promise.all([
      fetchAndDecompress('./TextMapCHS.json.gz'),
      fetchAndDecompress('./AvatarConfig.json.gz'),
      fetchAndDecompress('./VoiceAtlas.json.gz')
    ]);

    const avatarIdToName = loadAvatarIdToName(avatarData, textMapData);
    const graph = buildMentionGraph(voiceAtlasData, textMapData, avatarIdToName);
    
    // å…¨å±€å­˜å‚¨å›¾ï¼Œä¾›ç»“æœæ¸²æŸ“å‡½æ•°è®¡ç®—äº’æƒ æ€§
    window._GLOBAL_GRAPH = graph; 

    if (graph.order === 0) {
        throw new Error("æœªèƒ½æˆåŠŸæ„å»ºç½‘ç»œå›¾ã€‚è¯·æ£€æŸ¥æ•°æ®æ–‡ä»¶ç»“æ„å’Œè·¯å¾„æ˜¯å¦æ­£ç¡®ã€‚");
    }

    const analysisResults = analyzeGraph(graph);
    renderResults(analysisResults);
    
    // ç­‰å¾…åˆ†æç»“æœæ¸²æŸ“å®Œæˆåï¼Œå†åˆå§‹åŒ–ç½‘ç»œå›¾
    setTimeout(() => renderVisualization(graph), 100); 

  } catch (error) {
    vizContainer.innerHTML = ''; // æ¸…é™¤åŠ è½½æç¤º
    resultsDiv.innerHTML = `<p style="color:#d9534f; padding: 20px;">
        <strong>åˆ†æå¤±è´¥ï¼š</strong> ${error.message}
        <br><br>è¯·ç¡®ä¿ä»¥ä¸‹ Gzip å‹ç¼©æ–‡ä»¶ä¸æ­¤ HTML æ–‡ä»¶åœ¨åŒä¸€ç›®å½•ä¸‹ï¼Œå¹¶ä½¿ç”¨æ­£ç¡®çš„ HSR æ•°æ®ç»“æ„ï¼š
        <ul>
            <li>TextMapCHS.json.gz</li>
            <li>AvatarConfig.json.gz</li>
            <li>VoiceAtlas.json.gz</li>
        </ul>
        </p>`;
    console.error("ç½‘ç»œåˆ†æé”™è¯¯:", error);
  }
}

main();
</script>
</body>
</html>